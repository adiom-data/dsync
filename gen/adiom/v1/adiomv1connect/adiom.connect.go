// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: adiom/v1/adiom.proto

package adiomv1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/adiom-data/dsync/gen/adiom/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// ConnectorServiceName is the fully-qualified name of the ConnectorService service.
	ConnectorServiceName = "adiom.v1.ConnectorService"
	// TransformServiceName is the fully-qualified name of the TransformService service.
	TransformServiceName = "adiom.v1.TransformService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// ConnectorServiceGetInfoProcedure is the fully-qualified name of the ConnectorService's GetInfo
	// RPC.
	ConnectorServiceGetInfoProcedure = "/adiom.v1.ConnectorService/GetInfo"
	// ConnectorServiceGetNamespaceMetadataProcedure is the fully-qualified name of the
	// ConnectorService's GetNamespaceMetadata RPC.
	ConnectorServiceGetNamespaceMetadataProcedure = "/adiom.v1.ConnectorService/GetNamespaceMetadata"
	// ConnectorServiceWriteDataProcedure is the fully-qualified name of the ConnectorService's
	// WriteData RPC.
	ConnectorServiceWriteDataProcedure = "/adiom.v1.ConnectorService/WriteData"
	// ConnectorServiceWriteUpdatesProcedure is the fully-qualified name of the ConnectorService's
	// WriteUpdates RPC.
	ConnectorServiceWriteUpdatesProcedure = "/adiom.v1.ConnectorService/WriteUpdates"
	// ConnectorServiceGeneratePlanProcedure is the fully-qualified name of the ConnectorService's
	// GeneratePlan RPC.
	ConnectorServiceGeneratePlanProcedure = "/adiom.v1.ConnectorService/GeneratePlan"
	// ConnectorServiceListDataProcedure is the fully-qualified name of the ConnectorService's ListData
	// RPC.
	ConnectorServiceListDataProcedure = "/adiom.v1.ConnectorService/ListData"
	// ConnectorServiceStreamUpdatesProcedure is the fully-qualified name of the ConnectorService's
	// StreamUpdates RPC.
	ConnectorServiceStreamUpdatesProcedure = "/adiom.v1.ConnectorService/StreamUpdates"
	// ConnectorServiceStreamLSNProcedure is the fully-qualified name of the ConnectorService's
	// StreamLSN RPC.
	ConnectorServiceStreamLSNProcedure = "/adiom.v1.ConnectorService/StreamLSN"
	// TransformServiceGetTransformInfoProcedure is the fully-qualified name of the TransformService's
	// GetTransformInfo RPC.
	TransformServiceGetTransformInfoProcedure = "/adiom.v1.TransformService/GetTransformInfo"
	// TransformServiceGetTransformProcedure is the fully-qualified name of the TransformService's
	// GetTransform RPC.
	TransformServiceGetTransformProcedure = "/adiom.v1.TransformService/GetTransform"
)

// These variables are the protoreflect.Descriptor objects for the RPCs defined in this package.
var (
	connectorServiceServiceDescriptor                    = v1.File_adiom_v1_adiom_proto.Services().ByName("ConnectorService")
	connectorServiceGetInfoMethodDescriptor              = connectorServiceServiceDescriptor.Methods().ByName("GetInfo")
	connectorServiceGetNamespaceMetadataMethodDescriptor = connectorServiceServiceDescriptor.Methods().ByName("GetNamespaceMetadata")
	connectorServiceWriteDataMethodDescriptor            = connectorServiceServiceDescriptor.Methods().ByName("WriteData")
	connectorServiceWriteUpdatesMethodDescriptor         = connectorServiceServiceDescriptor.Methods().ByName("WriteUpdates")
	connectorServiceGeneratePlanMethodDescriptor         = connectorServiceServiceDescriptor.Methods().ByName("GeneratePlan")
	connectorServiceListDataMethodDescriptor             = connectorServiceServiceDescriptor.Methods().ByName("ListData")
	connectorServiceStreamUpdatesMethodDescriptor        = connectorServiceServiceDescriptor.Methods().ByName("StreamUpdates")
	connectorServiceStreamLSNMethodDescriptor            = connectorServiceServiceDescriptor.Methods().ByName("StreamLSN")
	transformServiceServiceDescriptor                    = v1.File_adiom_v1_adiom_proto.Services().ByName("TransformService")
	transformServiceGetTransformInfoMethodDescriptor     = transformServiceServiceDescriptor.Methods().ByName("GetTransformInfo")
	transformServiceGetTransformMethodDescriptor         = transformServiceServiceDescriptor.Methods().ByName("GetTransform")
)

// ConnectorServiceClient is a client for the adiom.v1.ConnectorService service.
type ConnectorServiceClient interface {
	GetInfo(context.Context, *connect.Request[v1.GetInfoRequest]) (*connect.Response[v1.GetInfoResponse], error)
	GetNamespaceMetadata(context.Context, *connect.Request[v1.GetNamespaceMetadataRequest]) (*connect.Response[v1.GetNamespaceMetadataResponse], error)
	// Sink
	WriteData(context.Context, *connect.Request[v1.WriteDataRequest]) (*connect.Response[v1.WriteDataResponse], error)
	WriteUpdates(context.Context, *connect.Request[v1.WriteUpdatesRequest]) (*connect.Response[v1.WriteUpdatesResponse], error)
	// Source
	GeneratePlan(context.Context, *connect.Request[v1.GeneratePlanRequest]) (*connect.Response[v1.GeneratePlanResponse], error)
	ListData(context.Context, *connect.Request[v1.ListDataRequest]) (*connect.Response[v1.ListDataResponse], error)
	StreamUpdates(context.Context, *connect.Request[v1.StreamUpdatesRequest]) (*connect.ServerStreamForClient[v1.StreamUpdatesResponse], error)
	StreamLSN(context.Context, *connect.Request[v1.StreamLSNRequest]) (*connect.ServerStreamForClient[v1.StreamLSNResponse], error)
}

// NewConnectorServiceClient constructs a client for the adiom.v1.ConnectorService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewConnectorServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) ConnectorServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &connectorServiceClient{
		getInfo: connect.NewClient[v1.GetInfoRequest, v1.GetInfoResponse](
			httpClient,
			baseURL+ConnectorServiceGetInfoProcedure,
			connect.WithSchema(connectorServiceGetInfoMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		getNamespaceMetadata: connect.NewClient[v1.GetNamespaceMetadataRequest, v1.GetNamespaceMetadataResponse](
			httpClient,
			baseURL+ConnectorServiceGetNamespaceMetadataProcedure,
			connect.WithSchema(connectorServiceGetNamespaceMetadataMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		writeData: connect.NewClient[v1.WriteDataRequest, v1.WriteDataResponse](
			httpClient,
			baseURL+ConnectorServiceWriteDataProcedure,
			connect.WithSchema(connectorServiceWriteDataMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		writeUpdates: connect.NewClient[v1.WriteUpdatesRequest, v1.WriteUpdatesResponse](
			httpClient,
			baseURL+ConnectorServiceWriteUpdatesProcedure,
			connect.WithSchema(connectorServiceWriteUpdatesMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		generatePlan: connect.NewClient[v1.GeneratePlanRequest, v1.GeneratePlanResponse](
			httpClient,
			baseURL+ConnectorServiceGeneratePlanProcedure,
			connect.WithSchema(connectorServiceGeneratePlanMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		listData: connect.NewClient[v1.ListDataRequest, v1.ListDataResponse](
			httpClient,
			baseURL+ConnectorServiceListDataProcedure,
			connect.WithSchema(connectorServiceListDataMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		streamUpdates: connect.NewClient[v1.StreamUpdatesRequest, v1.StreamUpdatesResponse](
			httpClient,
			baseURL+ConnectorServiceStreamUpdatesProcedure,
			connect.WithSchema(connectorServiceStreamUpdatesMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		streamLSN: connect.NewClient[v1.StreamLSNRequest, v1.StreamLSNResponse](
			httpClient,
			baseURL+ConnectorServiceStreamLSNProcedure,
			connect.WithSchema(connectorServiceStreamLSNMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// connectorServiceClient implements ConnectorServiceClient.
type connectorServiceClient struct {
	getInfo              *connect.Client[v1.GetInfoRequest, v1.GetInfoResponse]
	getNamespaceMetadata *connect.Client[v1.GetNamespaceMetadataRequest, v1.GetNamespaceMetadataResponse]
	writeData            *connect.Client[v1.WriteDataRequest, v1.WriteDataResponse]
	writeUpdates         *connect.Client[v1.WriteUpdatesRequest, v1.WriteUpdatesResponse]
	generatePlan         *connect.Client[v1.GeneratePlanRequest, v1.GeneratePlanResponse]
	listData             *connect.Client[v1.ListDataRequest, v1.ListDataResponse]
	streamUpdates        *connect.Client[v1.StreamUpdatesRequest, v1.StreamUpdatesResponse]
	streamLSN            *connect.Client[v1.StreamLSNRequest, v1.StreamLSNResponse]
}

// GetInfo calls adiom.v1.ConnectorService.GetInfo.
func (c *connectorServiceClient) GetInfo(ctx context.Context, req *connect.Request[v1.GetInfoRequest]) (*connect.Response[v1.GetInfoResponse], error) {
	return c.getInfo.CallUnary(ctx, req)
}

// GetNamespaceMetadata calls adiom.v1.ConnectorService.GetNamespaceMetadata.
func (c *connectorServiceClient) GetNamespaceMetadata(ctx context.Context, req *connect.Request[v1.GetNamespaceMetadataRequest]) (*connect.Response[v1.GetNamespaceMetadataResponse], error) {
	return c.getNamespaceMetadata.CallUnary(ctx, req)
}

// WriteData calls adiom.v1.ConnectorService.WriteData.
func (c *connectorServiceClient) WriteData(ctx context.Context, req *connect.Request[v1.WriteDataRequest]) (*connect.Response[v1.WriteDataResponse], error) {
	return c.writeData.CallUnary(ctx, req)
}

// WriteUpdates calls adiom.v1.ConnectorService.WriteUpdates.
func (c *connectorServiceClient) WriteUpdates(ctx context.Context, req *connect.Request[v1.WriteUpdatesRequest]) (*connect.Response[v1.WriteUpdatesResponse], error) {
	return c.writeUpdates.CallUnary(ctx, req)
}

// GeneratePlan calls adiom.v1.ConnectorService.GeneratePlan.
func (c *connectorServiceClient) GeneratePlan(ctx context.Context, req *connect.Request[v1.GeneratePlanRequest]) (*connect.Response[v1.GeneratePlanResponse], error) {
	return c.generatePlan.CallUnary(ctx, req)
}

// ListData calls adiom.v1.ConnectorService.ListData.
func (c *connectorServiceClient) ListData(ctx context.Context, req *connect.Request[v1.ListDataRequest]) (*connect.Response[v1.ListDataResponse], error) {
	return c.listData.CallUnary(ctx, req)
}

// StreamUpdates calls adiom.v1.ConnectorService.StreamUpdates.
func (c *connectorServiceClient) StreamUpdates(ctx context.Context, req *connect.Request[v1.StreamUpdatesRequest]) (*connect.ServerStreamForClient[v1.StreamUpdatesResponse], error) {
	return c.streamUpdates.CallServerStream(ctx, req)
}

// StreamLSN calls adiom.v1.ConnectorService.StreamLSN.
func (c *connectorServiceClient) StreamLSN(ctx context.Context, req *connect.Request[v1.StreamLSNRequest]) (*connect.ServerStreamForClient[v1.StreamLSNResponse], error) {
	return c.streamLSN.CallServerStream(ctx, req)
}

// ConnectorServiceHandler is an implementation of the adiom.v1.ConnectorService service.
type ConnectorServiceHandler interface {
	GetInfo(context.Context, *connect.Request[v1.GetInfoRequest]) (*connect.Response[v1.GetInfoResponse], error)
	GetNamespaceMetadata(context.Context, *connect.Request[v1.GetNamespaceMetadataRequest]) (*connect.Response[v1.GetNamespaceMetadataResponse], error)
	// Sink
	WriteData(context.Context, *connect.Request[v1.WriteDataRequest]) (*connect.Response[v1.WriteDataResponse], error)
	WriteUpdates(context.Context, *connect.Request[v1.WriteUpdatesRequest]) (*connect.Response[v1.WriteUpdatesResponse], error)
	// Source
	GeneratePlan(context.Context, *connect.Request[v1.GeneratePlanRequest]) (*connect.Response[v1.GeneratePlanResponse], error)
	ListData(context.Context, *connect.Request[v1.ListDataRequest]) (*connect.Response[v1.ListDataResponse], error)
	StreamUpdates(context.Context, *connect.Request[v1.StreamUpdatesRequest], *connect.ServerStream[v1.StreamUpdatesResponse]) error
	StreamLSN(context.Context, *connect.Request[v1.StreamLSNRequest], *connect.ServerStream[v1.StreamLSNResponse]) error
}

// NewConnectorServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewConnectorServiceHandler(svc ConnectorServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	connectorServiceGetInfoHandler := connect.NewUnaryHandler(
		ConnectorServiceGetInfoProcedure,
		svc.GetInfo,
		connect.WithSchema(connectorServiceGetInfoMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	connectorServiceGetNamespaceMetadataHandler := connect.NewUnaryHandler(
		ConnectorServiceGetNamespaceMetadataProcedure,
		svc.GetNamespaceMetadata,
		connect.WithSchema(connectorServiceGetNamespaceMetadataMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	connectorServiceWriteDataHandler := connect.NewUnaryHandler(
		ConnectorServiceWriteDataProcedure,
		svc.WriteData,
		connect.WithSchema(connectorServiceWriteDataMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	connectorServiceWriteUpdatesHandler := connect.NewUnaryHandler(
		ConnectorServiceWriteUpdatesProcedure,
		svc.WriteUpdates,
		connect.WithSchema(connectorServiceWriteUpdatesMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	connectorServiceGeneratePlanHandler := connect.NewUnaryHandler(
		ConnectorServiceGeneratePlanProcedure,
		svc.GeneratePlan,
		connect.WithSchema(connectorServiceGeneratePlanMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	connectorServiceListDataHandler := connect.NewUnaryHandler(
		ConnectorServiceListDataProcedure,
		svc.ListData,
		connect.WithSchema(connectorServiceListDataMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	connectorServiceStreamUpdatesHandler := connect.NewServerStreamHandler(
		ConnectorServiceStreamUpdatesProcedure,
		svc.StreamUpdates,
		connect.WithSchema(connectorServiceStreamUpdatesMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	connectorServiceStreamLSNHandler := connect.NewServerStreamHandler(
		ConnectorServiceStreamLSNProcedure,
		svc.StreamLSN,
		connect.WithSchema(connectorServiceStreamLSNMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/adiom.v1.ConnectorService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case ConnectorServiceGetInfoProcedure:
			connectorServiceGetInfoHandler.ServeHTTP(w, r)
		case ConnectorServiceGetNamespaceMetadataProcedure:
			connectorServiceGetNamespaceMetadataHandler.ServeHTTP(w, r)
		case ConnectorServiceWriteDataProcedure:
			connectorServiceWriteDataHandler.ServeHTTP(w, r)
		case ConnectorServiceWriteUpdatesProcedure:
			connectorServiceWriteUpdatesHandler.ServeHTTP(w, r)
		case ConnectorServiceGeneratePlanProcedure:
			connectorServiceGeneratePlanHandler.ServeHTTP(w, r)
		case ConnectorServiceListDataProcedure:
			connectorServiceListDataHandler.ServeHTTP(w, r)
		case ConnectorServiceStreamUpdatesProcedure:
			connectorServiceStreamUpdatesHandler.ServeHTTP(w, r)
		case ConnectorServiceStreamLSNProcedure:
			connectorServiceStreamLSNHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedConnectorServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedConnectorServiceHandler struct{}

func (UnimplementedConnectorServiceHandler) GetInfo(context.Context, *connect.Request[v1.GetInfoRequest]) (*connect.Response[v1.GetInfoResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("adiom.v1.ConnectorService.GetInfo is not implemented"))
}

func (UnimplementedConnectorServiceHandler) GetNamespaceMetadata(context.Context, *connect.Request[v1.GetNamespaceMetadataRequest]) (*connect.Response[v1.GetNamespaceMetadataResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("adiom.v1.ConnectorService.GetNamespaceMetadata is not implemented"))
}

func (UnimplementedConnectorServiceHandler) WriteData(context.Context, *connect.Request[v1.WriteDataRequest]) (*connect.Response[v1.WriteDataResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("adiom.v1.ConnectorService.WriteData is not implemented"))
}

func (UnimplementedConnectorServiceHandler) WriteUpdates(context.Context, *connect.Request[v1.WriteUpdatesRequest]) (*connect.Response[v1.WriteUpdatesResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("adiom.v1.ConnectorService.WriteUpdates is not implemented"))
}

func (UnimplementedConnectorServiceHandler) GeneratePlan(context.Context, *connect.Request[v1.GeneratePlanRequest]) (*connect.Response[v1.GeneratePlanResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("adiom.v1.ConnectorService.GeneratePlan is not implemented"))
}

func (UnimplementedConnectorServiceHandler) ListData(context.Context, *connect.Request[v1.ListDataRequest]) (*connect.Response[v1.ListDataResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("adiom.v1.ConnectorService.ListData is not implemented"))
}

func (UnimplementedConnectorServiceHandler) StreamUpdates(context.Context, *connect.Request[v1.StreamUpdatesRequest], *connect.ServerStream[v1.StreamUpdatesResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("adiom.v1.ConnectorService.StreamUpdates is not implemented"))
}

func (UnimplementedConnectorServiceHandler) StreamLSN(context.Context, *connect.Request[v1.StreamLSNRequest], *connect.ServerStream[v1.StreamLSNResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("adiom.v1.ConnectorService.StreamLSN is not implemented"))
}

// TransformServiceClient is a client for the adiom.v1.TransformService service.
type TransformServiceClient interface {
	GetTransformInfo(context.Context, *connect.Request[v1.GetTransformInfoRequest]) (*connect.Response[v1.GetTransformInfoResponse], error)
	GetTransform(context.Context, *connect.Request[v1.GetTransformRequest]) (*connect.Response[v1.GetTransformResponse], error)
}

// NewTransformServiceClient constructs a client for the adiom.v1.TransformService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewTransformServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) TransformServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &transformServiceClient{
		getTransformInfo: connect.NewClient[v1.GetTransformInfoRequest, v1.GetTransformInfoResponse](
			httpClient,
			baseURL+TransformServiceGetTransformInfoProcedure,
			connect.WithSchema(transformServiceGetTransformInfoMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		getTransform: connect.NewClient[v1.GetTransformRequest, v1.GetTransformResponse](
			httpClient,
			baseURL+TransformServiceGetTransformProcedure,
			connect.WithSchema(transformServiceGetTransformMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// transformServiceClient implements TransformServiceClient.
type transformServiceClient struct {
	getTransformInfo *connect.Client[v1.GetTransformInfoRequest, v1.GetTransformInfoResponse]
	getTransform     *connect.Client[v1.GetTransformRequest, v1.GetTransformResponse]
}

// GetTransformInfo calls adiom.v1.TransformService.GetTransformInfo.
func (c *transformServiceClient) GetTransformInfo(ctx context.Context, req *connect.Request[v1.GetTransformInfoRequest]) (*connect.Response[v1.GetTransformInfoResponse], error) {
	return c.getTransformInfo.CallUnary(ctx, req)
}

// GetTransform calls adiom.v1.TransformService.GetTransform.
func (c *transformServiceClient) GetTransform(ctx context.Context, req *connect.Request[v1.GetTransformRequest]) (*connect.Response[v1.GetTransformResponse], error) {
	return c.getTransform.CallUnary(ctx, req)
}

// TransformServiceHandler is an implementation of the adiom.v1.TransformService service.
type TransformServiceHandler interface {
	GetTransformInfo(context.Context, *connect.Request[v1.GetTransformInfoRequest]) (*connect.Response[v1.GetTransformInfoResponse], error)
	GetTransform(context.Context, *connect.Request[v1.GetTransformRequest]) (*connect.Response[v1.GetTransformResponse], error)
}

// NewTransformServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewTransformServiceHandler(svc TransformServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	transformServiceGetTransformInfoHandler := connect.NewUnaryHandler(
		TransformServiceGetTransformInfoProcedure,
		svc.GetTransformInfo,
		connect.WithSchema(transformServiceGetTransformInfoMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	transformServiceGetTransformHandler := connect.NewUnaryHandler(
		TransformServiceGetTransformProcedure,
		svc.GetTransform,
		connect.WithSchema(transformServiceGetTransformMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/adiom.v1.TransformService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case TransformServiceGetTransformInfoProcedure:
			transformServiceGetTransformInfoHandler.ServeHTTP(w, r)
		case TransformServiceGetTransformProcedure:
			transformServiceGetTransformHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedTransformServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedTransformServiceHandler struct{}

func (UnimplementedTransformServiceHandler) GetTransformInfo(context.Context, *connect.Request[v1.GetTransformInfoRequest]) (*connect.Response[v1.GetTransformInfoResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("adiom.v1.TransformService.GetTransformInfo is not implemented"))
}

func (UnimplementedTransformServiceHandler) GetTransform(context.Context, *connect.Request[v1.GetTransformRequest]) (*connect.Response[v1.GetTransformResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("adiom.v1.TransformService.GetTransform is not implemented"))
}
