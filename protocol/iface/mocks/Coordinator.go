// Code generated by mockery v2.41.0. DO NOT EDIT.

package mocks

import (
	context "context"

	iface "github.com/adiom-data/dsync/protocol/iface"
	mock "github.com/stretchr/testify/mock"
)

// Coordinator is an autogenerated mock type for the Coordinator type
type Coordinator struct {
	mock.Mock
}

// DelistConnector provides a mock function with given fields: _a0
func (_m *Coordinator) DelistConnector(_a0 iface.ConnectorID) {
	_m.Called(_a0)
}

// FlowCreate provides a mock function with given fields: o
func (_m *Coordinator) FlowCreate(o iface.FlowOptions) (iface.FlowID, error) {
	ret := _m.Called(o)

	if len(ret) == 0 {
		panic("no return value specified for FlowCreate")
	}

	var r0 iface.FlowID
	var r1 error
	if rf, ok := ret.Get(0).(func(iface.FlowOptions) (iface.FlowID, error)); ok {
		return rf(o)
	}
	if rf, ok := ret.Get(0).(func(iface.FlowOptions) iface.FlowID); ok {
		r0 = rf(o)
	} else {
		r0 = ret.Get(0).(iface.FlowID)
	}

	if rf, ok := ret.Get(1).(func(iface.FlowOptions) error); ok {
		r1 = rf(o)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FlowDestroy provides a mock function with given fields: fid
func (_m *Coordinator) FlowDestroy(fid iface.FlowID) {
	_m.Called(fid)
}

// FlowStart provides a mock function with given fields: fid
func (_m *Coordinator) FlowStart(fid iface.FlowID) error {
	ret := _m.Called(fid)

	if len(ret) == 0 {
		panic("no return value specified for FlowStart")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(iface.FlowID) error); ok {
		r0 = rf(fid)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FlowStop provides a mock function with given fields: fid
func (_m *Coordinator) FlowStop(fid iface.FlowID) {
	_m.Called(fid)
}

// GetConnectors provides a mock function with given fields:
func (_m *Coordinator) GetConnectors() []iface.ConnectorDetails {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetConnectors")
	}

	var r0 []iface.ConnectorDetails
	if rf, ok := ret.Get(0).(func() []iface.ConnectorDetails); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]iface.ConnectorDetails)
		}
	}

	return r0
}

// GetFlowStatus provides a mock function with given fields: fid
func (_m *Coordinator) GetFlowStatus(fid iface.FlowID) (iface.FlowStatus, error) {
	ret := _m.Called(fid)

	if len(ret) == 0 {
		panic("no return value specified for GetFlowStatus")
	}

	var r0 iface.FlowStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(iface.FlowID) (iface.FlowStatus, error)); ok {
		return rf(fid)
	}
	if rf, ok := ret.Get(0).(func(iface.FlowID) iface.FlowStatus); ok {
		r0 = rf(fid)
	} else {
		r0 = ret.Get(0).(iface.FlowStatus)
	}

	if rf, ok := ret.Get(1).(func(iface.FlowID) error); ok {
		r1 = rf(fid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NotifyDataIntegrityCheckDone provides a mock function with given fields: flowId, conn, res
func (_m *Coordinator) NotifyDataIntegrityCheckDone(flowId iface.FlowID, conn iface.ConnectorID, res iface.ConnectorDataIntegrityCheckResponse) error {
	ret := _m.Called(flowId, conn, res)

	if len(ret) == 0 {
		panic("no return value specified for NotifyDataIntegrityCheckDone")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(iface.FlowID, iface.ConnectorID, iface.ConnectorDataIntegrityCheckResponse) error); ok {
		r0 = rf(flowId, conn, res)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NotifyDone provides a mock function with given fields: flowId, conn
func (_m *Coordinator) NotifyDone(flowId iface.FlowID, conn iface.ConnectorID) error {
	ret := _m.Called(flowId, conn)

	if len(ret) == 0 {
		panic("no return value specified for NotifyDone")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(iface.FlowID, iface.ConnectorID) error); ok {
		r0 = rf(flowId, conn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PerformFlowIntegrityCheck provides a mock function with given fields: fid
func (_m *Coordinator) PerformFlowIntegrityCheck(fid iface.FlowID) (iface.FlowDataIntegrityCheckResult, error) {
	ret := _m.Called(fid)

	if len(ret) == 0 {
		panic("no return value specified for PerformFlowIntegrityCheck")
	}

	var r0 iface.FlowDataIntegrityCheckResult
	var r1 error
	if rf, ok := ret.Get(0).(func(iface.FlowID) (iface.FlowDataIntegrityCheckResult, error)); ok {
		return rf(fid)
	}
	if rf, ok := ret.Get(0).(func(iface.FlowID) iface.FlowDataIntegrityCheckResult); ok {
		r0 = rf(fid)
	} else {
		r0 = ret.Get(0).(iface.FlowDataIntegrityCheckResult)
	}

	if rf, ok := ret.Get(1).(func(iface.FlowID) error); ok {
		r1 = rf(fid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterConnector provides a mock function with given fields: details, cep
func (_m *Coordinator) RegisterConnector(details iface.ConnectorDetails, cep iface.ConnectorICoordinatorSignal) (iface.ConnectorID, error) {
	ret := _m.Called(details, cep)

	if len(ret) == 0 {
		panic("no return value specified for RegisterConnector")
	}

	var r0 iface.ConnectorID
	var r1 error
	if rf, ok := ret.Get(0).(func(iface.ConnectorDetails, iface.ConnectorICoordinatorSignal) (iface.ConnectorID, error)); ok {
		return rf(details, cep)
	}
	if rf, ok := ret.Get(0).(func(iface.ConnectorDetails, iface.ConnectorICoordinatorSignal) iface.ConnectorID); ok {
		r0 = rf(details, cep)
	} else {
		r0 = ret.Get(0).(iface.ConnectorID)
	}

	if rf, ok := ret.Get(1).(func(iface.ConnectorDetails, iface.ConnectorICoordinatorSignal) error); ok {
		r1 = rf(details, cep)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Setup provides a mock function with given fields: ctx, t, s
func (_m *Coordinator) Setup(ctx context.Context, t iface.Transport, s iface.Statestore) {
	_m.Called(ctx, t, s)
}

// Teardown provides a mock function with given fields:
func (_m *Coordinator) Teardown() {
	_m.Called()
}

// UpdateConnectorStatus provides a mock function with given fields: flowId, conn, status
func (_m *Coordinator) UpdateConnectorStatus(flowId iface.FlowID, conn iface.ConnectorID, status iface.ConnectorStatus) error {
	ret := _m.Called(flowId, conn, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConnectorStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(iface.FlowID, iface.ConnectorID, iface.ConnectorStatus) error); ok {
		r0 = rf(flowId, conn, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WaitForFlowDone provides a mock function with given fields: flowId
func (_m *Coordinator) WaitForFlowDone(flowId iface.FlowID) error {
	ret := _m.Called(flowId)

	if len(ret) == 0 {
		panic("no return value specified for WaitForFlowDone")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(iface.FlowID) error); ok {
		r0 = rf(flowId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewCoordinator creates a new instance of Coordinator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCoordinator(t interface {
	mock.TestingT
	Cleanup(func())
}) *Coordinator {
	mock := &Coordinator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
