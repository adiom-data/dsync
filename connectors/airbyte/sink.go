package airbyte

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"

	"connectrpc.com/connect"
	adiomv1 "github.com/adiom-data/dsync/gen/adiom/v1"
	"github.com/adiom-data/dsync/gen/adiom/v1/adiomv1connect"
)

type sink struct {
	adiomv1connect.UnimplementedConnectorServiceHandler
	dockerImage  string
	config       string
	catalog      string
	chIn         chan []byte
	pendingState chan pendingState
	state        atomic.Int64
	err          error
	ctx          context.Context
	cancel       context.CancelFunc
	mut          sync.RWMutex
	done         chan struct{}
	once         sync.Once
}

// GetInfo implements adiomv1connect.ConnectorServiceHandler.
func (s *sink) GetInfo(context.Context, *connect.Request[adiomv1.GetInfoRequest]) (*connect.Response[adiomv1.GetInfoResponse], error) {
	return connect.NewResponse(&adiomv1.GetInfoResponse{
		DbType: fmt.Sprintf("airbyte-sink-%s", s.dockerImage),
		Capabilities: &adiomv1.Capabilities{
			Sink: &adiomv1.Capabilities_Sink{
				SupportedDataTypes: []adiomv1.DataType{adiomv1.DataType_DATA_TYPE_UNKNOWN}, // TODO
			},
		},
	}), nil
}

// WriteData implements adiomv1connect.ConnectorServiceHandler.
func (s *sink) WriteData(context.Context, *connect.Request[adiomv1.WriteDataRequest]) (*connect.Response[adiomv1.WriteDataResponse], error) {
	panic("unimplemented")
}

// WriteUpdates implements adiomv1connect.ConnectorServiceHandler.
func (s *sink) WriteUpdates(ctx context.Context, r *connect.Request[adiomv1.WriteUpdatesRequest]) (*connect.Response[adiomv1.WriteUpdatesResponse], error) {
	// This only runs once, but we do it here because if relying on the catalog generated by the source we can't set up at the start
	// Consider how to improve this
	s.Start()

	s.mut.RLock()
	if s.err != nil {
		s.mut.RUnlock()
		return nil, connect.NewError(connect.CodeInternal, s.err)
	}
	s.mut.RUnlock()
	var data [][]byte
	for _, d := range r.Msg.GetUpdates() {
		data = append(data, d.GetData())
	}
	if err := s.write(data); err != nil {
		return nil, connect.NewError(connect.CodeInternal, err)
	}

	return connect.NewResponse(&adiomv1.WriteUpdatesResponse{}), nil
}

type pendingState struct {
	state int64
	done  chan struct{}
}

func (s *sink) write(data [][]byte) error {
	s.mut.RLock()
	defer s.mut.RUnlock()
	if s.chIn == nil {
		return fmt.Errorf("closed for writes")
	}

	for _, d := range data {
		s.chIn <- d
	}

	state := s.state.Add(1)
	done := make(chan struct{})
	s.pendingState <- pendingState{state, done}

	s.chIn <- []byte(`{"type":"STATE","state":{"type":"LEGACY","data":{"state":` + strconv.FormatInt(state, 10) + `}}}`)

	<-done
	return nil
}

type SinkState struct {
	State struct {
		Data struct {
			State int64 `json:"state"`
		} `json:"data"`
	} `json:"state"`
}

func (s *sink) Start() {
	s.once.Do(func() {
		s.ctx, s.cancel = context.WithCancel(context.Background())
		executable := NewAirbyteExecutable(s.dockerImage)
		chOut := make(chan []byte)

		go func() {
			pendingStates := map[int64]pendingState{}
			chOut := chOut
			pendingStateCh := s.pendingState
			for {
				select {
				case p, ok := <-pendingStateCh:
					if !ok {
						pendingStateCh = nil
						if chOut == nil {
							break
						}
						continue
					}
					if _, ok := pendingStates[p.state]; ok {
						close(p.done)
						delete(pendingStates, p.state)
					} else {
						pendingStates[p.state] = p
					}
				case out, ok := <-chOut:
					if !ok {
						chOut = nil
						if pendingStateCh == nil {
							break
						}
						continue
					}
					if strings.Contains(string(out), "STATE") {
						var sinkState SinkState
						if err := json.Unmarshal(out, &sinkState); err != nil {
							s.mut.Lock()
							s.err = err
							s.mut.Unlock()
							return
						}
						state := sinkState.State.Data.State
						if p, ok := pendingStates[state]; ok && p.state == state {
							close(p.done)
							delete(pendingStates, state)
						} else {
							pendingStates[state] = pendingState{}
						}
					}
				}
			}
		}()

		go func() {
			if err := executable.Write(s.ctx, s.config, s.catalog, s.chIn, chOut); err != nil {
				s.mut.Lock()
				s.err = err
				s.mut.Unlock()
			}

			close(s.done)
		}()
	})
}

func (s *sink) Teardown() {
	s.mut.Lock()
	close(s.chIn)
	s.chIn = nil
	s.mut.Unlock()
	s.cancel()
	<-s.done
}

func NewSink(dockerImage string, config string, catalog string) adiomv1connect.ConnectorServiceHandler {
	return &sink{dockerImage: dockerImage, config: config, catalog: catalog, chIn: make(chan []byte), pendingState: make(chan pendingState), done: make(chan struct{})}
}
