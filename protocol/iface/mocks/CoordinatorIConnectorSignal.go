// Code generated by mockery v2.46.1. DO NOT EDIT.

package mocks

import (
	iface "github.com/adiom-data/dsync/protocol/iface"
	mock "github.com/stretchr/testify/mock"
)

// CoordinatorIConnectorSignal is an autogenerated mock type for the CoordinatorIConnectorSignal type
type CoordinatorIConnectorSignal struct {
	mock.Mock
}

// DelistConnector provides a mock function with given fields: _a0
func (_m *CoordinatorIConnectorSignal) DelistConnector(_a0 iface.ConnectorID) {
	_m.Called(_a0)
}

// NotifyDone provides a mock function with given fields: flowId, conn
func (_m *CoordinatorIConnectorSignal) NotifyDone(flowId iface.FlowID, conn iface.ConnectorID) error {
	ret := _m.Called(flowId, conn)

	if len(ret) == 0 {
		panic("no return value specified for NotifyDone")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(iface.FlowID, iface.ConnectorID) error); ok {
		r0 = rf(flowId, conn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NotifyTaskDone provides a mock function with given fields: flowId, conn, taskId, taskData
func (_m *CoordinatorIConnectorSignal) NotifyTaskDone(flowId iface.FlowID, conn iface.ConnectorID, taskId iface.ReadPlanTaskID, taskData *iface.TaskDoneMeta) error {
	ret := _m.Called(flowId, conn, taskId, taskData)

	if len(ret) == 0 {
		panic("no return value specified for NotifyTaskDone")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(iface.FlowID, iface.ConnectorID, iface.ReadPlanTaskID, *iface.TaskDoneMeta) error); ok {
		r0 = rf(flowId, conn, taskId, taskData)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PostReadPlanningResult provides a mock function with given fields: flowId, conn, res
func (_m *CoordinatorIConnectorSignal) PostReadPlanningResult(flowId iface.FlowID, conn iface.ConnectorID, res iface.ConnectorReadPlanResult) error {
	ret := _m.Called(flowId, conn, res)

	if len(ret) == 0 {
		panic("no return value specified for PostReadPlanningResult")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(iface.FlowID, iface.ConnectorID, iface.ConnectorReadPlanResult) error); ok {
		r0 = rf(flowId, conn, res)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RegisterConnector provides a mock function with given fields: details, cep
func (_m *CoordinatorIConnectorSignal) RegisterConnector(details iface.ConnectorDetails, cep iface.ConnectorICoordinatorSignal) (iface.ConnectorID, error) {
	ret := _m.Called(details, cep)

	if len(ret) == 0 {
		panic("no return value specified for RegisterConnector")
	}

	var r0 iface.ConnectorID
	var r1 error
	if rf, ok := ret.Get(0).(func(iface.ConnectorDetails, iface.ConnectorICoordinatorSignal) (iface.ConnectorID, error)); ok {
		return rf(details, cep)
	}
	if rf, ok := ret.Get(0).(func(iface.ConnectorDetails, iface.ConnectorICoordinatorSignal) iface.ConnectorID); ok {
		r0 = rf(details, cep)
	} else {
		r0 = ret.Get(0).(iface.ConnectorID)
	}

	if rf, ok := ret.Get(1).(func(iface.ConnectorDetails, iface.ConnectorICoordinatorSignal) error); ok {
		r1 = rf(details, cep)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateCDCResumeToken provides a mock function with given fields: flowId, conn, resumeToken
func (_m *CoordinatorIConnectorSignal) UpdateCDCResumeToken(flowId iface.FlowID, conn iface.ConnectorID, resumeToken []byte) error {
	ret := _m.Called(flowId, conn, resumeToken)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCDCResumeToken")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(iface.FlowID, iface.ConnectorID, []byte) error); ok {
		r0 = rf(flowId, conn, resumeToken)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateConnectorStatus provides a mock function with given fields: flowId, conn, status
func (_m *CoordinatorIConnectorSignal) UpdateConnectorStatus(flowId iface.FlowID, conn iface.ConnectorID, status iface.ConnectorStatus) error {
	ret := _m.Called(flowId, conn, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConnectorStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(iface.FlowID, iface.ConnectorID, iface.ConnectorStatus) error); ok {
		r0 = rf(flowId, conn, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewCoordinatorIConnectorSignal creates a new instance of CoordinatorIConnectorSignal. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCoordinatorIConnectorSignal(t interface {
	mock.TestingT
	Cleanup(func())
}) *CoordinatorIConnectorSignal {
	mock := &CoordinatorIConnectorSignal{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
